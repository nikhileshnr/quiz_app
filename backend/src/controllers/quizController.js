// Import the Quiz model
const Quiz = require('../models/quizModel');
const geminiService = require('../services/geminiService');
const User = require('../models/userModel');
const Invitation = require('../models/invitationModel');
const mongoose = require('mongoose');

// Verify that required models are properly imported
if (!Quiz) {
  console.error('ERROR: Quiz model failed to load');
}
if (!Invitation) {
  console.error('ERROR: Invitation model failed to load');
}

/**
 * Get all quizzes with pagination
 * @route GET /api/quiz
 */
exports.getAllQuizzes = async (req, res, next) => {
  try {
    // Parse query parameters
    const page = parseInt(req.query.page, 10) || 1;
    const limit = parseInt(req.query.limit, 10) || 10;
    const skip = (page - 1) * limit;
    
    // Build query filters based on request parameters
    const queryObj = { ...req.query };
    const excludedFields = ['page', 'sort', 'limit', 'fields'];
    excludedFields.forEach(field => delete queryObj[field]);
    
    // Process filters like difficulty, level, etc.
    let query = Quiz.find(queryObj);
    
    // Sort options
    if (req.query.sort) {
      const sortBy = req.query.sort.split(',').join(' ');
      query = query.sort(sortBy);
    } else {
      query = query.sort('-createdAt'); // Default sort by creation date
    }
    
    // Field limiting
    if (req.query.fields) {
      const fields = req.query.fields.split(',').join(' ');
      query = query.select(fields);
    }
    
    // Pagination
    query = query.skip(skip).limit(limit);
    
    // Execute query
    const quizzes = await query;
    const total = await Quiz.countDocuments(queryObj);
    
    // Send response
    res.status(200).json({
      status: 'success',
      results: quizzes.length,
      pagination: {
        total,
        page,
        limit,
        pages: Math.ceil(total / limit)
      },
      data: quizzes
    });
  } catch (error) {
    next(error);
  }
};

/**
 * Get a single quiz by ID
 * @route GET /api/quiz/:id
 */
exports.getQuiz = async (req, res, next) => {
  try {
    // Check if Quiz model is available
    if (!Quiz) {
      return res.status(500).json({
        status: 'error',
        message: 'Quiz model not available'
      });
    }
    
    // Check if ID is provided
    if (!req.params.id) {
      return res.status(400).json({
        status: 'error',
        message: 'Quiz ID is required'
      });
    }
    
    // Try to find quiz
    const quiz = await Quiz.findById(req.params.id).exec();
    
    if (!quiz) {
      return res.status(404).json({
        status: 'error',
        message: 'Quiz not found'
      });
    }
    
    res.status(200).json({
      status: 'success',
      data: quiz
    });
  } catch (error) {
    console.error('Error in getQuiz:', error);
    if (error.name === 'CastError') {
      return res.status(400).json({
        status: 'error',
        message: 'Invalid quiz ID format'
      });
    }
    next(error);
  }
};

/**
 * Create a manual quiz
 * @route POST /api/quiz/manual
 */
exports.createManualQuiz = async (req, res, next) => {
  try {
    // Use the authenticated user's ID
    if (req.user && req.user.id) {
      req.body.createdBy = req.user.id;
    } else {
      return res.status(401).json({
        status: 'error',
        message: 'User authentication required to create a quiz'
      });
    }
    
    // Set the generation method
    if (!req.body.generationMethod) {
      req.body.generationMethod = 'ai';
    }
    
    // Create new quiz
    const quiz = await Quiz.create(req.body);
    
    res.status(201).json({
      status: 'success',
      data: quiz
    });
  } catch (error) {
    console.error('Error in createManualQuiz:', error);
    if (error.name === 'ValidationError') {
      error.status = 400;
    }
    next(error);
  }
};

/**
 * Create an AI-generated quiz
 * @route POST /api/quiz/ai
 */
exports.createAIQuiz = async (req, res, next) => {
  try {
    const { topic, difficulty, level, questionCount } = req.body;
    
    console.log('AI Quiz Generation Request:', {
      topic,
      difficulty,
      level,
      questionCount: questionCount || 5
    });
    
    // Validate required fields manually to provide better error messages
    if (!topic) {
      return res.status(400).json({
        status: 'error',
        message: 'Topic is required'
      });
    }
    
    if (!difficulty) {
      return res.status(400).json({
        status: 'error',
        message: 'Difficulty is required'
      });
    }
    
    if (!level) {
      return res.status(400).json({
        status: 'error',
        message: 'Level is required'
      });
    }
    
    // Generate quiz with Gemini
    console.log('Calling Gemini service for quiz generation...');
    const generatedQuiz = await geminiService.generateQuiz({
      topic,
      difficulty,
      level,
      questionCount: questionCount || 5
    });
    
    console.log('Quiz successfully generated by AI. Returning without saving to database.');
    
    // Return the generated quiz without saving to database
    res.status(200).json({
      status: 'success',
      data: generatedQuiz
    });
  } catch (error) {
    console.error('Error in createAIQuiz:', error);
    
    if (error.name === 'ValidationError') {
      error.status = 400;
      console.error('Validation error:', error.message);
    } else {
      error.status = 500;
      console.error('Server error:', error.message);
    }
    
    // Send a meaningful error response
    res.status(error.status || 500).json({
      status: 'error',
      message: error.message || 'Failed to generate quiz'
    });
  }
};

/**
 * Update a quiz
 * @route PUT /api/quiz/:id
 */
exports.updateQuiz = async (req, res, next) => {
  try {
    const quiz = await Quiz.findByIdAndUpdate(
      req.params.id,
      req.body,
      {
        new: true, // Return the updated document
        runValidators: true // Run validators on update
      }
    );
    
    if (!quiz) {
      const error = new Error('Quiz not found');
      error.status = 404;
      return next(error);
    }
    
    res.status(200).json({
      status: 'success',
      data: quiz
    });
  } catch (error) {
    if (error.name === 'ValidationError') {
      error.status = 400;
    }
    next(error);
  }
};

/**
 * Delete a quiz
 * @route DELETE /api/quiz/:id
 */
exports.deleteQuiz = async (req, res, next) => {
  try {
    const quiz = await Quiz.findByIdAndDelete(req.params.id);
    
    if (!quiz) {
      const error = new Error('Quiz not found');
      error.status = 404;
      return next(error);
    }
    
    res.status(200).json({
      status: 'success',
      data: null
    });
  } catch (error) {
    next(error);
  }
};

/**
 * Verify a question using AI
 * @route POST /api/quiz/verify-question
 */
exports.verifyQuestion = async (req, res, next) => {
  try {
    const { question, originalQuestion, quizParams } = req.body;
    
    // Call geminiService to verify the question
    const verificationResult = await geminiService.verifyQuestion({
      question,
      originalQuestion,
      quizParams
    });
    
    res.status(200).json({
      status: 'success',
      data: verificationResult
    });
  } catch (error) {
    console.error('Error in verifyQuestion:', error);
    res.status(500).json({
      status: 'error',
      message: error.message || 'Failed to verify question'
    });
  }
};

/**
 * Regenerate specific questions in a quiz
 * @route POST /api/quiz/regenerate-questions
 */
exports.regenerateQuestions = async (req, res, next) => {
  try {
    const { quizParams, indicesToRegenerate, currentQuestions } = req.body;
    
    if (!quizParams || !indicesToRegenerate || !Array.isArray(indicesToRegenerate)) {
      return res.status(400).json({
        status: 'error',
        message: 'Invalid request format'
      });
    }
    
    // Call geminiService to regenerate the specified questions
    const regeneratedQuestions = await geminiService.regenerateQuestions({
      topic: quizParams.topic,
      difficulty: quizParams.difficulty,
      level: quizParams.level,
      indicesToRegenerate,
      currentQuestions
    });
    
    res.status(200).json({
      status: 'success',
      data: regeneratedQuestions
    });
  } catch (error) {
    console.error('Error in regenerateQuestions:', error);
    res.status(500).json({
      status: 'error',
      message: error.message || 'Failed to regenerate questions'
    });
  }
};

/**
 * Create a new quiz
 * @route POST /api/quiz
 * @access Private - Teachers only
 */
exports.createQuiz = async (req, res) => {
  try {
    // Ensure only teachers can create quizzes
    if (req.user.role !== 'teacher') {
      return res.status(403).json({
        success: false,
        message: 'Only teachers can create quizzes'
      });
    }

    // Add the teacher as the creator
    const quizData = {
      ...req.body,
      createdBy: req.user.id
    };

    const quiz = await Quiz.create(quizData);

    res.status(201).json({
      success: true,
      data: quiz
    });
  } catch (error) {
    console.error('Error creating quiz:', error);
    res.status(500).json({
      success: false,
      message: 'Error creating quiz',
      error: process.env.NODE_ENV === 'development' ? error.message : undefined
    });
  }
};

/**
 * Get all quizzes based on user role
 * @route GET /api/quiz
 * @access Private
 */
exports.getQuizzes = async (req, res) => {
  try {
    // Initialize empty quizzes array by default
    let quizzes = [];
    
    // Make sure req.user exists before attempting to use it
    if (!req.user) {
      console.log('User is not authenticated properly');
      return res.status(401).json({
        success: false,
        message: 'User authentication required',
        data: []
      });
    }
    
    // If teacher, return quizzes created by them
    if (req.user.role === 'teacher') {
      console.log('Fetching quizzes for teacher:', req.user.id);
      try {
        quizzes = await Quiz.aggregate([
          { $match: { createdBy: new mongoose.Types.ObjectId(req.user.id) } },
          {
            $project: {
              title: 1,
              difficulty: 1,
              level: 1,
              questionCount: { $size: '$questions' },
              createdAt: 1,
            },
          },
        ]);
          
        // Ensure quizzes is an array
        quizzes = Array.isArray(quizzes) ? quizzes : [];
      } catch (err) {
        console.error('Error fetching teacher quizzes:', err);
        quizzes = []; // Reset to empty array on error
      }
    } 
    // If student, return quizzes they've been invited to
    else if (req.user.role === 'student') {
      console.log('Fetching quizzes for student:', req.user.id);
      try {
        // Check if Invitation model is available
        if (!Invitation) {
          console.error('Invitation model is not available');
          return res.status(500).json({
            success: false,
            message: 'Internal server error with Invitation model',
            data: []
          });
        }
        
        // Get all accepted invitations for this student
        const invitations = await Invitation.find({
          student: req.user.id,
          status: { $in: ['accepted', 'pending'] }
        }).select('quiz');
        
        // Safely extract quiz IDs from invitations
        const quizIds = invitations && Array.isArray(invitations) 
          ? invitations.map(inv => inv && inv.quiz ? inv.quiz : null).filter(Boolean)
          : [];
        
        console.log(`Found ${quizIds.length} quiz invitations for student`);
        
        // Only query if there are quiz IDs
        if (quizIds.length > 0) {
          quizzes = await Quiz.aggregate([
            { $match: { _id: { $in: quizIds }, isActive: true } },
            {
              $project: {
                title: 1,
                difficulty: 1,
                level: 1,
                questionCount: { $size: '$questions' },
                createdAt: 1,
              },
            },
          ]);
          
          // Ensure quizzes is an array
          quizzes = Array.isArray(quizzes) ? quizzes : [];
        }
      } catch (err) {
        console.error('Error fetching student invitations:', err);
        quizzes = []; // Reset to empty array on error
      }
    } else {
      console.log('Unknown user role:', req.user.role);
      quizzes = []; // Default to empty array for unknown roles
    }
    
    // Final safety check to ensure quizzes is always an array
    if (!Array.isArray(quizzes)) {
      console.log('Quizzes is still not an array after processing, setting to empty array');
      quizzes = [];
    }
    
    console.log(`Returning ${quizzes.length} quizzes`);
    
    // Return consistent response format
    return res.status(200).json({
      success: true,
      count: quizzes.length,
      data: quizzes
    });
  } catch (error) {
    console.error('Error in getQuizzes:', error);
    return res.status(500).json({
      success: false,
      message: 'Error fetching quizzes',
      error: error.message || 'Unknown error',
      data: []  // Always include an empty data array even on error
    });
  }
};

/**
 * Get quiz results
 * @route GET /api/quiz/:id/results
 * @access Private - Teachers only
 */
exports.getQuizResults = async (req, res) => {
  try {
    // Only teachers can view results
    if (req.user.role !== 'teacher') {
      return res.status(403).json({
        success: false,
        message: 'Only teachers can view quiz results'
      });
    }
    
    // Find quiz and check ownership
    const quiz = await Quiz.findById(req.params.id)
      .populate({
        path: 'attempts.student',
        select: 'name email'
      });
    
    if (!quiz) {
      return res.status(404).json({
        success: false,
        message: 'Quiz not found'
      });
    }
    
    // Ensure teacher owns this quiz
    if (quiz.createdBy.toString() !== req.user.id) {
      return res.status(403).json({
        success: false,
        message: 'Access denied: not your quiz'
      });
    }
    
    // Extract and format results
    const results = {
      quizId: quiz._id,
      title: quiz.title,
      totalAttempts: quiz.attempts.length,
      averageScore: quiz.averageScore,
      attempts: quiz.attempts.map(attempt => ({
        student: {
          id: attempt.student._id,
          name: attempt.student.name,
          email: attempt.student.email
        },
        score: attempt.score,
        maxScore: attempt.maxScore,
        percentage: (attempt.score / attempt.maxScore) * 100,
        completedAt: attempt.completedAt
      }))
    };
    
    res.status(200).json({
      success: true,
      data: results
    });
  } catch (error) {
    console.error('Error fetching quiz results:', error);
    res.status(500).json({
      success: false,
      message: 'Error fetching quiz results',
      error: process.env.NODE_ENV === 'development' ? error.message : undefined
    });
  }
};

/**
 * Submit a quiz attempt
 * @route POST /api/quiz/:id/submit
 * @access Private - Students only
 */
exports.submitQuiz = async (req, res) => {
  try {
    // Only students can submit quiz answers
    if (req.user.role !== 'student') {
      return res.status(403).json({
        success: false,
        message: 'Only students can submit quizzes'
      });
    }
    
    // Find quiz
    const quiz = await Quiz.findById(req.params.id);
    
    if (!quiz) {
      return res.status(404).json({
        success: false,
        message: 'Quiz not found'
      });
    }
    
    // Check if student is invited to this quiz
    const invitation = await Invitation.findOne({
      quiz: quiz._id,
      student: req.user.id,
      status: { $in: ['accepted', 'pending'] }
    });
    
    if (!invitation) {
      return res.status(403).json({
        success: false,
        message: 'Access denied: you are not invited to this quiz'
      });
    }
    
    // Process answers and calculate score
    const { answers } = req.body;
    let score = 0;
    const maxScore = quiz.questions.length;
    
    const processedAnswers = answers.map((answer, index) => {
      const question = quiz.questions[index];
      const isCorrect = Array.isArray(answer) 
        ? answer.length === question.correctAnswers.length &&
          answer.every(ans => question.correctAnswers.includes(ans))
        : question.correctAnswers.includes(answer);
        
      if (isCorrect) score++;
      
      return {
        questionIndex: index,
        selectedOptions: Array.isArray(answer) ? answer : [answer],
        isCorrect
      };
    });
    
    // Create attempt record
    const attempt = {
      student: req.user.id,
      score,
      maxScore,
      answers: processedAnswers,
      completedAt: new Date()
    };
    
    // Add attempt to quiz
    quiz.attempts.push(attempt);
    await quiz.save();
    
    // Update invitation status to completed
    invitation.status = 'completed';
    invitation.responseAt = new Date();
    await invitation.save();
    
    res.status(200).json({
      success: true,
      data: {
        score,
        maxScore,
        percentage: (score / maxScore) * 100
      }
    });
  } catch (error) {
    console.error('Error submitting quiz:', error);
    res.status(500).json({
      success: false,
      message: 'Error submitting quiz',
      error: process.env.NODE_ENV === 'development' ? error.message : undefined
    });
  }
};

/**
 * Get my quiz attempts (for students)
 * @route GET /api/quiz/my-attempts
 * @access Private - Students only
 */
exports.getMyAttempts = async (req, res) => {
  try {
    // Only students can view their own attempts
    if (req.user.role !== 'student') {
      return res.status(403).json({
        success: false,
        message: 'Only students can view their quiz attempts'
      });
    }
    
    // Find all quizzes containing attempts by this student
    const quizzes = await Quiz.find({
      'attempts.student': req.user.id
    }).select('title attempts');
    
    // Extract just the attempts for this student
    const attempts = [];
    
    quizzes.forEach(quiz => {
      const studentAttempts = quiz.attempts.filter(
        attempt => attempt.student.toString() === req.user.id
      );
      
      studentAttempts.forEach(attempt => {
        attempts.push({
          quizId: quiz._id,
          quizTitle: quiz.title,
          score: attempt.score,
          maxScore: attempt.maxScore,
          percentage: (attempt.score / attempt.maxScore) * 100,
          completedAt: attempt.completedAt
        });
      });
    });
    
    // Sort by most recent first
    attempts.sort((a, b) => new Date(b.completedAt) - new Date(a.completedAt));
    
    res.status(200).json({
      success: true,
      count: attempts.length,
      data: attempts
    });
  } catch (error) {
    console.error('Error fetching quiz attempts:', error);
    res.status(500).json({
      success: false,
      message: 'Error fetching quiz attempts',
      error: process.env.NODE_ENV === 'development' ? error.message : undefined
    });
  }
}; 